package codf

type Parser Peg {
	err error

	// Float precision
	Precision uint

	// stages []stage
	root *Root

	sign        int
	consumers   []consumer
	baseIntBase int
}


###############
## Structure ##
###############

Root <- { p.init() } Body* OptSpace EOF

Body <- OptSpace Decl

Decl <- Section
	/ Statement
	/ Sentinel

# NAME [EXPR];
Statement <- Name                       { p.beginStatement(text) }
       ( ReqSpace Expr )*               # Parameters
       OptSpace Sentinel                { p.closeStatement() }

# NAME [EXPR] {...}
Section <- Name                         { p.beginSection(text) }
	( ReqSpace Expr )*              # Parameters
	OptSpace '{'
	Body*
	OptSpace '}'                    { p.closeSection() }

Name <- Bareword

Expr <- Literal
ExprList <- Expr ( ReqSpace Expr )*


##############
## Literals ##
##############

Literal <- Duration
        / { p.sign = 1 } Number
	/ Boolean
	/ Regexp
	/ String
	/ Symbol
	/ Map
	/ Array

# Arrays
Array <- '[' OptSpace                   { p.beginArray() }
	ExprList?
	OptSpace ']'                    { p.closeArray() }

# Maps
Map <- '#{' OptSpace                    { p.beginMap() }
	MapPairs?
	OptSpace '}'                    { p.closeMap() }

MapPairs <- MapPair (ReqSpace MapPair)*
MapPair  <- MapKey ReqSpace MapValue
MapKey   <- String / Symbol
MapValue <- Expr


# Symbols
Symbol <- Bareword                      { p.consume(Symbol(text)) }
	/ '#' QuotedString              { p.consume(Symbol(unquote(typeSymbol, text))) }
Bareword <- < BarewordInitial BarewordTail* >

BarewordInitial <- [[.?/!@$%^&*|_A-Z]]
BarewordTail    <- [[-+=<>.?/!@$%^&*#|:_A-Z0-9]]

# Regexp
Regexp <- '#/'                          { p.beginRegexp() }
	regexpBody*
	'/'                             { p.closeRegexp() }
# regexpFlags <- [[A-Z]]*
regexpBody <- regexpEscape
	/ regexpTail
regexpTail <- < [^\\/]+ >               { p.tip().(*regexpBuilder).add(text) }
regexpEscape <- '\\/'                   { p.tip().(*regexpBuilder).add("/") }


# Strings
String <- QuotedString                  { p.consume(String(unquote(typeString, text))) }

QuotedString <- < '"' StringBody* '"' >
StringBody <- Escape
	/ '\\"'
	/ !'"' .

# Generic escape -- omits quotes
Escape <- '\\a'
	/ '\\b'
	/ '\\f'
	/ '\\n'
	/ '\\r'
	/ '\\t'
	/ '\\v'
	/ OctEscape
	/ HexEscape
	/ UnicodeShortEscape
	/ UnicodeWideEscape

OctEscape <- '\\' OctDigit OctDigit OctDigit
HexEscape <- '\\x' HexByte

UnicodeShortEscape <- '\\u' HexByte HexByte
UnicodeWideEscape  <- '\\U' HexByte HexByte HexByte HexByte

# Number
Number <- Sign? ( Decimal / Rational / Integer ) !BarewordTail

OctDigit <- [0-8]
HexDigit <- [[0-9A-F]]
HexByte  <- HexDigit HexDigit

# Rationals
Rational <- < Int '/' PosInt >          { p.consumeRational(text) }

# Decimals
Decimal <- PointDecimal                 { p.consumeFloat(text) }
	/ ExpDecimal                    { p.consumeFloat(text) }

PointDecimal <- < Int '.' Int Exponent? >
ExpDecimal   <- < Int Exponent >
Exponent     <- [Ee] [-+]? Int

# Integers
Integer <- BaseInt
	/ HexLit
	/ BinLit
	/ OctLit
	/ DecInt

Int    <- '0' / PosInt
PosInt <- [1-9][0-9]*

DecInt <- < Int >                       { p.consumeInteger(text, 10) }

BaseInt <- NumBase                      { p.parseBase(text) }
	'#' NumLit                      { p.consumeInteger(text, p.baseIntBase) }
# Bases 2-36
NumBase <- < [12] [0-9] / '3' [0-6] / [2-9] ![0-9] >
NumLit  <- < [[A-Z0-9]]+ >

HexLit <- "0x" < HexDigit+ >            { p.consumeInteger(text, 16) }
OctLit <- '0'  < [0-7]+ > ![8-9]        { p.consumeInteger(text, 8) }
BinLit <- "0b" < [01]+ > ![2-9]         { p.consumeInteger(text, 2) }

Sign   <- '-'                           { p.sign = -1 }
	/ '+'                           { p.sign = 1 }

# Booleans
Boolean <- True                         { p.consume(Bool(true)) }
	/ False                         { p.consume(Bool(false)) }
TrueKw  <- 'true' / 'True' / 'TRUE'
	/ 'yes' / 'Yes' / 'YES'
	# Still debating on the use of on/off for booleans
	# / 'on' / 'On' / 'ON'
FalseKw <- 'false' / 'False' / 'FALSE'
	/ 'no' / 'No' / 'NO'
	# / 'off' / 'Off' / 'OFF'
True    <- TrueKw !BarewordTail
False   <- FalseKw !BarewordTail

# Durations
Duration <- DurSpec !BarewordTail       { p.consumeDuration(text) }

DurSpec <- < [-+]? (DurNum DurUnit)+ >
DurNum  <- Int ( '.' Int )?
DurUnit <- 'ms'
        / 'ns'
        / 'us'
        / 'Âµs'
        / 'h'
        / 'm'
        / 's'

#################
## Punctuation ##
#################

Sentinel <- ';'

Space    <- [ \t\n\r]+ / Comment
ReqSpace <- Space+
OptSpace <- Space*

Comment <- '\'' (!EOL .)* ( EOL / EOF )

EOL <- '\r\n' / '\n' / '\r'

EOF <- !.
